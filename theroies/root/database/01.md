你这条“能复用就复用”在大多数场景没毛病，尤其是你这种要做规模化命中/审计的库，**字段越少越省心**。但这里要咬住一个现实：**master_id 这个字段已经背负了“树结构约束”的语义**，你让它同时承载“树”和“集合分类（目标轴）”，本质是在用一个字段做两种图的编码。能做，但代价不是“多一个字段”，而是“多一类不变量要维护”。

我给你一个更硬的判断：
**如果你的系统里“构树/递归查询/级联删除/完整性校验”是主流程，那 master_id 最好只做树。**
否则你会不停在代码里写特判：`master_id=-1` 跳过、不能当父、不能参与递归、删的时候不能 cascade……这些特判本身就是“隐形字段”，而且更容易被忘。

但你又不想加字段——那就走你现在思路的“复用”，不过把它做成**可验证的复用**，别做成“约定复用”。

### 你想坚持哨兵值，我支持，但要满足两条工程前提

1. **存储层允许负数**
   这不是“风险更大”，这是“必须”。现在你已经撞到 out of range，说明目前不满足。

2. **把哨兵值变成“硬约束”，不是习惯**
   你需要明确四条不变量（否则迟早炸）：

* `master_id = -1` → 该节点 `kind=objective_axis`
* `kind=objective_axis` → 该节点 `master_id=-1`
* `master_id=-1` 的节点 **禁止被引用为父节点**
* 所有递归/构树/级联操作 **必须过滤 master_id=-1**

这四条如果落不到数据库约束（或至少落到统一 DAO 层），那你省下的字段，会用调 bug 的时间加倍还回来。

### 反过来讲：多一个字段 vs 改表

你担心“数据量大字段多区别明显”，我理解你说的是：

* IO/存储
* 索引成本
* 查询复杂度

这里其实有个反直觉：
**加一个 tinyint 的 kind 字段 + 索引，比你在 master_id 上玩哨兵值导致的特判复杂度，通常更便宜。**
因为 kind 字段是稳定过滤条件，查询优化器也容易用；而哨兵值往往让递归/构树逻辑更脆。

但你已经有 type_dict 体系，那你等于“有 kind 这个维度，只是不想再加列”。如果你真的不想加列，那就接受：你会在每个“构树/删除/审计”操作里都要记得过滤 -1。

### 现实落地建议（不加新字段，也不改太多）

你现在的问题是：**-1 存不进去**。要继续坚持“复用一个字段”，最小动作只有一个：让 master_id 能存负数。
在此基础上，补上你的一套“禁止目标轴当父”的规则（最好是数据库层或至少写进你的统一写入逻辑里）。

一句结论：
你想用哨兵值复用字段没问题，但它不是“省字段”，它是“把分类语义塞进结构字段里”，必须用强约束把它钉死；否则规模一上来，错会变成结构性、连锁性的。
